package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &ClusterResource{}
var _ resource.ResourceWithImportState = &ClusterResource{}

// NewClusterResource creates a new ClusterResource.
func NewClusterResource() resource.Resource {
	return &ClusterResource{}
}

// ClusterResource defines the resource implementation.
type ClusterResource struct {
	client         *http.Client
	token          string
	organizationID string
}

// ClusterResourceModel describes the resource data model.
type ClusterResourceModel struct {
	ID                  types.String `tfsdk:"id"`
	Name                types.String `tfsdk:"name"`
	NamespaceID         types.String `tfsdk:"namespace_id"`
	Domain              types.String `tfsdk:"domain"`
	FQDN                types.String `tfsdk:"fqdn"`
	AutoDetectIPAddress types.String `tfsdk:"auto_detect_ip_address"`
	CreatedAt           types.String `tfsdk:"created_at"`
	UpdatedAt           types.String `tfsdk:"updated_at"`
}

// Metadata sets the resource type name for the ClusterResource.
func (r *ClusterResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_cluster"
}

// Schema defines the structure and attributes of the ClusterResource.
func (r *ClusterResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Pomerium Zero Cluster. This resource allows you to create, update, and delete clusters in your Pomerium Zero organization.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				MarkdownDescription: "The unique identifier of the cluster. This is automatically generated by Pomerium Zero.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				MarkdownDescription: "The name of the cluster. This must be unique within your organization.",
				Required:            true,
			},
			"namespace_id": schema.StringAttribute{
				MarkdownDescription: "The namespace ID of the cluster. This is automatically generated by Pomerium Zero and is used for creating routes and policies.",
				Computed:            true,
			},
			"domain": schema.StringAttribute{
				MarkdownDescription: "The domain associated with this cluster. This is used to generate the FQDN for the cluster.",
				Required:            true,
			},
			"fqdn": schema.StringAttribute{
				MarkdownDescription: "The fully qualified domain name (FQDN) of the cluster. This is automatically generated based on the cluster's domain.",
				Computed:            true,
			},
			"auto_detect_ip_address": schema.StringAttribute{
				MarkdownDescription: "The auto-detected IP address of the cluster. This is determined by Pomerium Zero.",
				Computed:            true,
			},
			"created_at": schema.StringAttribute{
				MarkdownDescription: "The timestamp when the cluster was created.",
				Computed:            true,
			},
			"updated_at": schema.StringAttribute{
				MarkdownDescription: "The timestamp when the cluster was last updated.",
				Computed:            true,
			},
		},
	}
}

// Configure prepares a Pomerium Zero API client for the ClusterResource.
func (r *ClusterResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	provider, ok := req.ProviderData.(*pomeriumZeroProvider)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *pomeriumZeroProvider, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	r.client = provider.client
	r.token = provider.token
	r.organizationID = provider.organizationID
}

// Create creates a new cluster in Pomerium Zero.
func (r *ClusterResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan ClusterResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Create the cluster
	cluster, err := r.createCluster(ctx, plan)
	if err != nil {
		resp.Diagnostics.AddError("Error creating cluster", err.Error())
		return
	}

	updateClusterResourceModel(&plan, cluster)

	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
}

// Read retrieves information about a Pomerium Zero cluster.
func (r *ClusterResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state ClusterResourceModel
	// Read Terraform configuration data into the model
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Fetch the cluster from Pomerium Zero
	cluster, err := r.getCluster(ctx, state.ID.ValueString())
	if err != nil {
		if strings.Contains(err.Error(), "cluster not found") {
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Error reading cluster", err.Error())
		return
	}

	// Map the fetched cluster data to our ClusterResourceModel
	updateClusterResourceModel(&state, cluster)

	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
}

// Update updates an existing cluster in Pomerium Zero.
func (r *ClusterResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan ClusterResourceModel
	// Read the updated Terraform configuration data into the model
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Update the cluster
	cluster, err := r.updateCluster(ctx, plan)
	if err != nil {
		resp.Diagnostics.AddError("Error updating cluster", err.Error())
		return
	}

	updateClusterResourceModel(&plan, cluster)

	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
}

// Delete deletes a cluster from Pomerium Zero.
func (r *ClusterResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state ClusterResourceModel
	// Read Terraform configuration data into the model
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Delete the cluster
	err := r.deleteCluster(ctx, state.ID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error deleting cluster", err.Error())
		return
	}
}

// ImportState imports an existing cluster into Terraform.
func (r *ClusterResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// The import ID is now expected to be the cluster name
	name := req.ID

	// Find the cluster by name
	cluster, err := r.findClusterByName(ctx, name)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error importing cluster",
			fmt.Sprintf("Could not find cluster with name %s: %s", name, err),
		)
		return
	}

	// Set all the attributes
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), cluster.ID)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), cluster.Name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace_id"), cluster.NamespaceID)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("domain"), cluster.Domain)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("fqdn"), cluster.FQDN)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("auto_detect_ip_address"), cluster.AutoDetectIPAddress)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("created_at"), cluster.CreatedAt)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("updated_at"), cluster.UpdatedAt)...)
}

// ExportState exports the state of a cluster.
func (r *ClusterResource) findClusterByName(ctx context.Context, name string) (*Cluster, error) {
	// Fetch all clusters
	url := fmt.Sprintf("%s/organizations/%s/clusters", apiBaseURL, r.organizationID)
	// Create a new request
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	// Set the Authorization header
	req.Header.Set("Authorization", "Bearer "+r.token)
	// Make the request
	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error making request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	var clusters []Cluster
	if err := json.NewDecoder(resp.Body).Decode(&clusters); err != nil {
		return nil, fmt.Errorf("error decoding response: %w", err)
	}

	for _, cluster := range clusters {
		if cluster.Name == name {
			return &cluster, nil
		}
	}

	return nil, fmt.Errorf("cluster with name %s not found", name)
}

// createCluster creates a new cluster in Pomerium Zero.
func (r *ClusterResource) createCluster(ctx context.Context, plan ClusterResourceModel) (*Cluster, error) {
	// Assemble the API URL
	url := fmt.Sprintf("%s/organizations/%s/clusters", apiBaseURL, r.organizationID)

	body := map[string]interface{}{
		"name":   plan.Name.ValueString(),
		"domain": plan.Domain.ValueString(),
	}

	jsonBody, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("error marshaling cluster: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, strings.NewReader(string(jsonBody)))
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+r.token)
	req.Header.Set("Content-Type", "application/json")

	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error making request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	var cluster Cluster
	if err := json.NewDecoder(resp.Body).Decode(&cluster); err != nil {
		return nil, fmt.Errorf("error decoding response: %w", err)
	}

	return &cluster, nil
}

// getCluster fetches a cluster from Pomerium Zero.
func (r *ClusterResource) getCluster(ctx context.Context, id string) (*Cluster, error) {
	// Assemble the API URL
	url := fmt.Sprintf("%s/organizations/%s/clusters/%s", apiBaseURL, r.organizationID, id)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+r.token)

	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error making request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		return nil, fmt.Errorf("cluster not found")
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	var cluster Cluster
	if err := json.NewDecoder(resp.Body).Decode(&cluster); err != nil {
		return nil, fmt.Errorf("error decoding response: %w", err)
	}

	return &cluster, nil
}

// updateCluster updates a cluster in Pomerium Zero.
func (r *ClusterResource) updateCluster(ctx context.Context, plan ClusterResourceModel) (*Cluster, error) {
	// Assemble the API URL
	url := fmt.Sprintf("%s/organizations/%s/clusters/%s", apiBaseURL, r.organizationID, plan.ID.ValueString())

	body := map[string]interface{}{
		"name":   plan.Name.ValueString(),
		"domain": plan.Domain.ValueString(),
	}

	jsonBody, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("error marshaling cluster: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, strings.NewReader(string(jsonBody)))
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+r.token)
	req.Header.Set("Content-Type", "application/json")

	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error making request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	var cluster Cluster
	if err := json.NewDecoder(resp.Body).Decode(&cluster); err != nil {
		return nil, fmt.Errorf("error decoding response: %w", err)
	}

	return &cluster, nil
}

// deleteCluster deletes a cluster from Pomerium Zero.
func (r *ClusterResource) deleteCluster(ctx context.Context, id string) error {
	url := fmt.Sprintf("%s/organizations/%s/clusters/%s", apiBaseURL, r.organizationID, id)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+r.token)

	resp, err := r.client.Do(req)
	if err != nil {
		return fmt.Errorf("error making request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNoContent {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	return nil
}

// updateClusterResourceModel updates the ClusterResourceModel with the data from the Cluster.
func updateClusterResourceModel(model *ClusterResourceModel, cluster *Cluster) {
	model.ID = types.StringValue(cluster.ID)
	model.Name = types.StringValue(cluster.Name)
	model.NamespaceID = types.StringValue(cluster.NamespaceID)
	model.Domain = types.StringValue(cluster.Domain)
	model.FQDN = types.StringValue(cluster.FQDN)
	model.AutoDetectIPAddress = types.StringValue(cluster.AutoDetectIPAddress)
	model.CreatedAt = types.StringValue(cluster.CreatedAt)
	model.UpdatedAt = types.StringValue(cluster.UpdatedAt)
}
